#!/usr/bin/env python3

import abc
import argparse
import contextlib
import io
import readline
import shlex
import sys

try:
    from pulsectl import Pulse, PulseSinkInfo, PulseSinkInputInfo, \
                         PulseSourceInfo, PulseSourceOutputInfo, \
                         PulseVolumeInfo
except ImportError:
    print('Please install pulsectl for Python 3 (pip3 install pulsectl)')
    sys.exit(1)


def trueround(val):
    '''
    Traditional rounding where less than halfway between integers is rounded
    down and greater than or equal to halfway is rounded up. This is needed
    since the round function in Python 3 rounds towards the even integer.
    '''
    return int(val // 1 + (1 if val % 1 >= 0.5 else 0))


@property
def is_flat_volume(self):
    '''
    Determine whether all channels have the same volume for a sink, sink-
    input, source, or source-output.

    :return: Whether or not all channels have a flat volume
    :rtype: bool
    '''
    return len(set(self.volume.values)) == 1


# For conviency, add the property to the PulseSinkInfo, PulseSinkInputInfo,
# PulseSourceInfo, and PulseSourceOutputInfo classes.
PulseSinkInfo.is_flat_volume = is_flat_volume
PulseSinkInputInfo.is_flat_volume = is_flat_volume
PulseSourceInfo.is_flat_volume = is_flat_volume
PulseSourceOutputInfo.is_flat_volume = is_flat_volume


@property
def sink_input_or_source_output_pid(self):
    '''
    Retrieve the pid for a sink-input or source-output.

    :return: The pid for the sink-input/source-output or None if not set
    :rtype: int or None
    '''
    key = 'application.process.id'
    return key in self.proplist and self.proplist[key] or None


# For conviency, add the property to the PulseSinkInputInfo and
# PulseSourceOutputInfo classes
PulseSinkInputInfo.pid = sink_input_or_source_output_pid
PulseSourceOutputInfo.pid = sink_input_or_source_output_pid


class BaseController(metaclass=abc.ABCMeta):
    '''
    Base wrapper for PulseAudio tasks.
    '''

    def __init__(self, clientobj):
        '''
        Base wrapper
        '''
        self._client = clientobj

    @abc.abstractmethod
    def find_sink(self, query):
        '''
        Find a sink based on a query.

        :param query: The query string
        :type query: PulseSinkInfo or str or int
        :return: The sink that was found
        :rtype: PulseSinkInfo or None
        '''
        pass

    @abc.abstractmethod
    def find_sink_input(self, query, pid=False):
        '''
        Find a sink-input based on a query. If the pid keyword is set, then
        the query string will search the application.process.id in the
        proplist instead of the name or id of the sink-input.

        :param query: The query string
        :type query: PulseSinkInputInfo or str or int
        :param pid: Whether to check the pid
        :return: The sink-input that was found
        :rtype: PulseSinkInputInfo or None
        '''
        pass

    @abc.abstractmethod
    def find_source(self, query):
        '''
        Find a source based on a query.

        :param query: The query string
        :type query: PulseSourceInfo or str or int
        :return: The source that was found
        :rtype: PulseSourceInfo or None
        '''
        pass

    @abc.abstractmethod
    def find_source_output(self, query, pid=False):
        '''
        Find a source-output based on a query. If the pid keyword is set, then
        the query string will search the application.process.id in the
        proplist instead of the name or id of the source-output.

        :param query: The query string
        :type query: PulseSourceOutputInfo or str or int
        :param pid: Whether to check the pid
        :return: The source-output that was found
        :rtype: PulseSourceOutputInfo or None
        '''
        pass

    @property
    def max_sink_width(self):
        '''
        Retrieve the maximum length of a sink name.

        :return: The maximum length of a sink name
        :rtype: int
        '''
        return len(max(self.sinks, key=lambda s: len(s.name)).name)

    @property
    def max_sink_input_width(self):
        '''
        Retrieve the maximum length of a sink-input name.

        :return: The maximum length of a sink-input name
        :rtype: int
        '''
        return len(max(self.sink_inputs, key=lambda si: len(si.name)).name)

    @property
    def max_source_width(self):
        '''
        Retrieve the maximum length of a source name.

        :return: The maximum length of a source name
        :rtype: int
        '''
        return len(max(self.sources, key=lambda s: len(s.name)).name)

    @property
    def max_source_output_width(self):
        '''
        Retrieve the maximum length of a source-output name.

        :return: The maximum length of a source-output name
        :rtype: int
        '''
        return len(max(self.source_outputs, key=lambda so: len(so.name)).name)

    @property
    def sinks(self):
        '''
        Retrieve a tuple of sinks on the server.

        :return: A tuple of PulseSinkInfo objects
        :rtype: tuple
        '''
        return self._client.sink_list()

    @property
    def sink_inputs(self):
        '''
        Retrieve a tuple of sink-inputs on the server.

        :return: A tuple of PulseSinkInputInfo objects
        :rtype: tuple
        '''
        return self._client.sink_input_list()

    @property
    def sources(self):
        '''
        Retrieve a tuple of sources on the server.

        :return: A tuple of PulseSourceInfo objects
        :rtype: tuple
        '''
        return self._client.source_list()

    @property
    def source_outputs(self):
        '''
        Retrieve a tuple of source-outputs on the server.

        :return: A tuple of PulseSourceOutputInfo objects
        :rtype: tuple
        '''
        return self._client.source_output_list()


class SinkController(BaseController):
    '''
    Wrapper around sink related tasks in PulseAudio.
    '''

    def __init__(self, clientobj):
        '''
        Create a wrapper for sink related tasks.
        '''
        BaseController.__init__(self, clientobj)

    @property
    def default_sink(self):
        '''
        Retrieve the default sink name.

        :return: The default sink name
        :rtype: str
        '''
        return self._client.server_info().default_sink_name

    @default_sink.setter
    def default_sink(self, sink):
        '''
        Set the default sink.

        :param sink: The sink object or sink query string
        :type sink: PulseSinkInfo or str or int
        :raises ValueError: If the sink is not found
        '''
        sobj = self.find_sink(sink)
        if sobj:
            self._client.default_set(sobj)
        else:
            raise ValueError(f"Sink {sink} not found")

    def display_default_sink_status(self, description=False, volsym='\uf028',
                                    mutesym='\uf026'):
        '''
        Retrieve information about the default sink. This has been designed
        to be used for status monitors. It has been tested with both i3blocks
        and polybar with the FontAwesome font, but should work with any status
        monitor. If you are using a font other than FontAwesome, you may need
        to set volsym and mutesym.

        :param bool description: Display the description instead of name
        :param str volsym: The symbol to show for volume (def: \uf028)
        :param str mutesym: The symbol to show when muted (def: \uf026)
        :return: The default sink status line
        :rtype: str
        '''
        defsink = self.find_sink('-')
        muteind = defsink.mute and mutesym or volsym
        title = defsink.description if description else defsink.name
        print(f"{muteind} {title}", end='')
        if defsink.is_flat_volume:
            print(f" {trueround(defsink.volume.values[0] * 100)}%")
        else:
            for vol in defsink.volume.values:
                print(f" {trueround(vol * 100)}%", end='')
            print()

    def display_sink(self, sink, props=False):
        '''
        Display formatted information for a sink. If props is set, then
        display the property list for the sink as well.

        :param sink: The sink object or sink query string
        :type sink: PulseSinkInfo or str or int
        :param bool props: Whether or not to display property list
        :raises ValueError: If sink not found
        '''
        # Find sink object
        sobj = self.find_sink(sink)
        if not sobj:
            raise ValueError(f"Sink {sink} not found")

        # Status indicators
        defind = sobj.name == self.default_sink and '*' or ' '
        muteind = sobj.mute and 'M' or ' '

        # Print the information
        width = max(30, self.max_sink_width)
        print(f"{defind} {sobj.index:2} {sobj.name:{width}} {muteind}", end='')
        for value in sobj.volume.values:
            print(f"  {trueround(value * 100):3}", end='')
        print(f"\t{sobj.description}")

        # If requested, print the property list
        if props:
            size = len(max(sobj.proplist.keys(), key=len))
            for key, value in sorted(sobj.proplist.items()):
                print(f"\t{key:{size}}\t{value}")
            print()

    def display_sinks(self, props=False):
        '''
        Display a formatted table of the sinks. If props is given, then
        display the property lists for each sink as well.

        :param bool props: Display the property list for each sink
        '''
        for sink in self.sinks:
            self.display_sink(sink, props=props)

    def find_sink(self, query):
        '''
        Try to find a sink that matches the given input query. The method of
        searching is to see if the query is an exact match to the sink name,
        description, or index. A hyphen (-) can be given as the query to
        return the default sink. If the query does not match _exactly_ one
        sink, then None is returned. For convience, if a PulseSinkInfo object
        is given, it will be returned.

        :param query: The query of the sink to search for
        :type query: str or int or PulseSinkInfo
        :return: The sink found
        :rtype: PulseSinkInfo or None
        '''
        if isinstance(query, PulseSinkInfo):
            return query

        query = str(query) if query != '-' else self.default_sink
        res = tuple(s for s in self.sinks
                    if query in (s.name, s.description, str(s.index)))

        return len(res) == 1 and res[0] or None

    def get_sink_volumes(self, sink, names=False):
        '''
        Retrieve the volumes for each channel of a sink. If names is set, then
        the result will be a dict with the channel name as the key and volume
        as the value.

        :param sink: The sink object or query string
        :type sink: PulseSinkInfo or str or int
        :param bool names: Whether or not to include channel names
        :return: A tuple of volumes or dict of name:volume pairs
        :rtype: tuple or dict
        :raises ValueError: If sink not found
        '''
        sobj = self.find_sink(sink)
        if not sobj:
            raise ValueError(f"Sink {sink} not found")

        if names:
            return {n: trueround(v * 100)
                    for n, v in zip(sobj.channel_list, sobj.volume.values)}
        else:
            return tuple(trueround(value * 100)
                         for value in sobj.volume.values)

    def is_sink_muted(self, sink):
        '''
        Retrieves whether or not a sink is muted.

        :param sink: The sink object or query string
        :type sink: PulseSinkInfo or str or int
        :return: The mute status of the sink
        :rtype: int
        :raises ValueError: If sink not found
        '''
        sobj = self.find_sink(sink)
        if not sobj:
            raise ValueError(f"Sink {sink} not found")
        return sobj.mute

    def mute_sink(self, sink, mute):
        '''
        Set the mute status of a sink.

        :param sink: The sink object or query string
        :type sink: PulseSinkInfo or str or int
        :param mute: '0' (mute), '1' (audible), or 't' (toggle)
        :type mute: str or int
        :raises ValueError: If sink not found or the mute state is invalid
        '''
        sobj = self.find_sink(sink)
        if not sobj:
            raise ValueError(f"Sink {sink} not found")

        if mute == 't':
            mute = 0 if sobj.mute else 1

        if mute is not None:
            self._client.sink_mute(sobj.index, int(mute))
        else:
            raise ValueError(f"Mute should be '0', '1', or 't' not {mute}")

    def set_sink_volumes(self, sink, volumes):
        '''
        Set the volume for the channels of a sink.

        :param sink: The sink object or query string
        :type sink: PulseSinkInfo or str or int
        :param volumes: The volumes for each channel or a flat volume
        :type volumes: list or tuple
        :raises ValueError: If sink not found or incorrect channel count given
        '''
        sobj = self.find_sink(sink)
        if not sobj:
            raise ValueError(f"Sink {sink} not found")

        if len(volumes) == sobj.channel_count:
            volinfo = PulseVolumeInfo([v / 100 for v in volumes])
        elif len(volumes) == 1:
            flatvol = [v / 100 for v in volumes]
            volinfo = PulseVolumeInfo(flatvol * sobj.channel_count)
        else:
            raise ValueError(f"Sink {sink} has {sobj.channel_count} channels. "
                             "Provide a volume per channel or a single flat "
                             "volume")

        self._client.sink_volume_set(sobj.index, volinfo)

    def set_sink_volumes_relative(self, sink, volumes):
        '''
        Adjust the volume for the channels of a sink by a relative amount

        :param sink: The sink object or query string
        :type sink: PulseSinkInfo or str or int
        :param volumes: The relative volume(s) to adjust by
        :type volumes: list or tuple
        :raises ValueError: If sink not found or incorrect channel count given
        '''
        sobj = self.find_sink(sink)
        if not sobj:
            raise ValueError(f"Sink {sink} not found")

        current = sobj.volume.values
        if len(volumes) == sobj.channel_count:
            volinfo = PulseVolumeInfo([c + v / 100
                                       for c, v in zip(current, volumes)])
        elif len(volumes) == 1:
            volinfo = PulseVolumeInfo([c + volumes[0] / 100 for c in current])
        else:
            raise ValueError(f"Sink {sink} has {sobj.channel_count} channels. "
                             "Provide a volume per channel or a single flat "
                             "volume")

        self._client.sink_volume_set(sobj.index, volinfo)


class SinkInputController(BaseController):
    '''
    Wrapper around sink-inputs in PulseAudio.
    '''

    def __init__(self, clientobj):
        '''
        Create a wrapper around sink-inputs.
        '''
        BaseController.__init__(self, clientobj)

    def display_sink_input(self, sinput, pid=False, props=False):
        '''
        Display sink-inputs for the client. The sink-input may be given as a
        query or PulseSinkInputInfo object. If a query is given, the pid
        keyword will control whether or not to search based on the pid of the
        application associated with the sink-input. If props is given, the
        property list will be outputted.

        :param sinput: The sink-input or query
        :type sinput: PulseSinkInfo or None
        :param bool pid: Whether or not to interpret the query as a pid
        :param bool props: Whether or not to output the property lists
        :raises ValueError: If the sink-input is not found
        :raises RuntimeError: If input is associated with an unknown sink
        '''
        # Find the sink-input
        siobj = self.find_sink_input(sinput, pid=pid)
        if not siobj:
            raise ValueError(f"Sink-input {sinput} not found")

        # Find the sink that it is being outputted to
        sobj = self.find_sink(siobj.sink)
        if not siobj:
            raise RuntimeError(f"Sink-input {sinput} is using unknown sink")

        # Indicitors
        muteind = siobj.mute and 'M' or ' '

        # Print basic information
        width = max(30, self.max_sink_input_width)
        sinkwidth = max(30, self.max_sink_width)
        print(f"{siobj.index:6} {siobj.name:{width}} {siobj.sink:2} ",
              f"{sobj.name:{sinkwidth}} {muteind}", end='')
        for value in siobj.volume.values:
            print(f" {trueround(value * 100):3}", end='')
        print()

        # If desired, print proplist
        if props:
            size = len(max(siobj.proplist.keys(), key=len))
            for key, value in sorted(siobj.proplist.items()):
                print(f"\t{key:{size}}\t{value}")
            print()

    def display_sink_inputs(self, shall=False, props=False):
        '''
        Display the sink-inputs in a table. If the shall keyword is True, then
        all sink-inputs will be displayed. Otherwise, sink-inputs with the
        role of filter will be ommitted. If the props keyword is True, then
        the property lists will be outputted.
        '''
        for sinput in self.sink_inputs:
            if shall or sinput.proplist.get('media.role', None) != "filter":
                self.display_sink_input(sinput, props=props)

    def find_sink_input(self, query, pid=False):
        '''
        Try to find a sink-input that matches a given input query. By default,
        the search checks to see if the name or index of any sink-input
        matches the query. If the pid keyword is set to True, then the
        property `application.process.id` is checked instead. If the query
        does not match _exactly_ one sink-input, then None is returned. For
        convience, if a PulseSinkInputInfo is given as the query, it will be
        returned.

        :param query: The query of the sink-input to search for
        :type query: str or int or PulseSinkInputInfo
        :param bool pid: Check the associated pid instead (default is False)
        :return: The sink-input found
        :rtype: PulseSinkInputInfo or None
        '''
        if isinstance(query, PulseSinkInputInfo):
            return query

        query = str(query)
        if pid:
            res = tuple(s for s in self.sink_inputs
                        if str(query) in (s.pid, ))
        else:
            res = tuple(s for s in self.sink_inputs
                        if str(query) in (s.name, str(s.index)))

        return len(res) == 1 and res[0] or None

    def get_sink_input_pid(self, sinput):
        '''
        Retrieve the pid of the sink-input.

        :param sinput: The sink-input or query string
        :type sinput: PulseSinkInputInfo or str or int
        :return: The pid of the sink-input, if one is associated
        :rtype: int or None
        '''
        siobj = self.find_sink_input(sinput, pid=False)
        if not siobj:
            raise ValueError(f"Sink-input {sinput} not found")
        return siobj.pid

    def get_sink_input_sink(self, sinput, pid=False):
        '''
        Retrieve which sink a sink-input is playing out of.

        :param sinput: The sink-input object or query string
        :type sinput: PulseSinkInputInfo or str or int
        :param bool pid: Whether or not to interpret the query as a pid
        :return: The sink
        :rtype: PulseSinkInfo
        :raises ValueError: If the sink-input is not found
        '''
        siobj = self.find_sink_input(sinput, pid=pid)
        if not siobj:
            raise ValueError(f"Sink-input {sinput} not found")
        return self.find_sink(siobj.sink)

    def get_sink_input_volumes(self, sinput, names=False, pid=False):
        '''
        Retrieve the volumes for each channel of a sink-input. If names is set,
        then the result will be a dict with the channel name as the key and
        volume as the value.

        :param sinput: The sink-input object or query string
        :type sinput: PulseSinkInputInfo or str or int
        :param bool names: Whether or not to include channel names
        :param bool pid: Whether or not to interpret the query as a pid
        :return: A tuple of volumes or dict of name:volume pairs
        :rtype: tuple or dict
        :raises ValueError: If sink-input not found
        '''
        siobj = self.find_sink_input(sinput, pid=pid)
        if not siobj:
            raise ValueError(f"Sink-input {sinput} not found")

        if names:
            return {n: trueround(v * 100)
                    for n, v in zip(siobj.channel_list, siobj.volume.values)}
        else:
            return tuple(trueround(value * 100)
                         for value in siobj.volume.values)

    def is_sink_input_muted(self, sinput, pid=False):
        '''
        Retrieves whether or not a sink-input is muted.

        :param sinput: The sink-input object or query string
        :type sinput: PulseSinkInputInfo or str or int
        :param bool pid: Whether or not to treat the query as a pid
        :return: The mute status of the sink-input
        :rtype: int
        :raises ValueError: If sink-input not found
        '''
        siobj = self.find_sink_input(sinput, pid=pid)
        if not siobj:
            raise ValueError(f"Sink-input {sinput} not found")
        return siobj.mute

    def move_sink_input(self, sinput, sink, pid=False):
        '''
        Move a sink-input to a sink.

        :param sinput: The sink-input object or query string
        :type sinput: PulseSinkInputInfo or str or int
        :param sink: The sink object or query string
        :type sink: PulseSinkInfo or str or int
        :param bool pid: Whether or not to interpret the query as a pid
        :raises ValueError: If the sink-input or sink is not found
        '''
        # Find sink-input
        siobj = self.find_sink_input(sinput, pid=pid)
        if not siobj:
            raise ValueError(f"Sink-input {sinput} not found")

        # Find sink
        sobj = self.find_sink(sink)
        if not sobj:
            raise ValueError(f"Sink {sink} not found")

        # Move to sink
        self._client.sink_input_move(siobj.index, sobj.index)

    def mute_sink_input(self, sinput, mute, pid=False):
        '''
        Set the mute status of a sink-input.

        :param sinput: The sink-input object or query string
        :type sinput: PulseSinkInputInfo or str or int
        :param mute: '0' (mute), '1' (audible), or 't' (toggle)
        :type mute: str or int
        :param bool pid: Whether or not to treat the query as a pid
        :raises ValueError: If sink-input not found or mute status is invalid
        '''
        siobj = self.find_sink_input(sinput, pid=pid)
        if not siobj:
            raise ValueError(f"Sink-input {sinput} not found")

        if mute == 't':
            mute = 0 if siobj.mute else 1

        if mute is not None:
            self._client.sink_input_mute(siobj.index, int(mute))
        else:
            raise ValueError(f"Mute should be '0', '1', or 't' not {mute}")

    def set_sink_input_volumes(self, sinput, volumes, pid=False):
        '''
        Set the volume for the channels of a sink-input.

        :param sinput: The sink-input object or query string
        :type sinput: PulseSinkInputInfo or str or int
        :param volumes: The volumes for each channel or a flat volume
        :type volumes: list or tuple
        :param bool pid: Whether or not to interpret the query as a pid
        :raises ValueError: If sink not found or incorrect channel count given
        '''
        siobj = self.find_sink_input(sinput, pid=pid)
        if not siobj:
            raise ValueError(f"Sink-input {sinput} not found")

        if len(volumes) == siobj.channel_count:
            volinfo = PulseVolumeInfo([v / 100 for v in volumes])
        elif len(volumes) == 1:
            flatvol = [v / 100 for v in volumes]
            volinfo = PulseVolumeInfo(flatvol * siobj.channel_count)
        else:
            raise ValueError(f"Sink-input {sinput} has {siobj.channel_count} "
                             "channels. Provide a volume per channel or a "
                             "single flat volume")

        self._client.sink_input_volume_set(siobj.index, volinfo)

    def set_sink_input_volumes_relative(self, sinput, volumes, pid=False):
        '''
        Adjust the volume for the channels of a sink-input by a relative
        amount.

        :param sinput: The sink-input object or query string
        :type sinput: PulseSinkInputInfo or str or int
        :param volumes: The relative volume(s) to adjust by
        :type volumes: list or tuple
        :param bool pid: Whether or not to interpret the query as a pid
        :raises ValueError: If sink not found or incorrect channel count given
        '''
        siobj = self.find_sink_input(sinput, pid=pid)
        if not siobj:
            raise ValueError(f"Sink-input {sinput} not found")

        current = siobj.volume.values
        if len(volumes) == siobj.channel_count:
            volinfo = PulseVolumeInfo([c + v / 100
                                       for c, v in zip(current, volumes)])
        elif len(volumes) == 1:
            volinfo = PulseVolumeInfo([c + volumes[0] / 100 for c in current])
        else:
            raise ValueError(f"Sink-input {sinput} has {siobj.channel_count} "
                             "channels. Provide a volume per channel or a "
                             "single flat volume")

        self._client.sink_input_volume_set(siobj.index, volinfo)


class SourceController(BaseController):
    '''
    Wrapper around source related tasks in PulseAudio.
    '''

    def __init__(self, clientobj):
        '''
        Create a wrapper for source related tasks.
        '''
        BaseController.__init__(self, clientobj)

    @property
    def default_source(self):
        '''
        Retrieve the default source name.

        :return: The default source name
        :rtype: str
        '''
        return self._client.server_info().default_source_name

    @default_source.setter
    def default_source(self, source):
        '''
        Set the default source.

        :param source: The source object or source query string
        :type source: PulseSourceInfo or str or int
        :raises ValueError: If the source is not found
        '''
        scobj = self.find_source(source)
        if scobj:
            self._client.source_default_set(scobj)
        else:
            raise ValueError(f"Source {source} not found")

    def display_source(self, source, props=False):
        '''
        Display formatted information for a source. If props is set, then
        display the property list for the source as well.

        :param sink: The source object or source query string
        :type sink: PulseSourceInfo or str or int
        :param bool props: Whether or not to display property list
        :raises ValueError: If source not found
        '''
        # Find source object
        scobj = self.find_source(source)
        if not scobj:
            raise ValueError(f"Source {source} not found")

        # Status indicators
        defind = scobj.name == self.default_source and '*' or ' '
        muteind = scobj.mute and 'M' or ' '

        # Print the information
        width = max(30, self.max_source_width)
        print(f"{defind} {scobj.index:2} {scobj.name:{width}} {muteind}",
              end='')
        for value in scobj.volume.values:
            print(f"  {trueround(value * 100):3}", end='')
        print(f"\t{scobj.description}")

        # If requested, print the property list
        if props:
            size = len(max(scobj.proplist.keys(), key=len))
            for key, value in sorted(scobj.proplist.items()):
                print(f"\t{key:{size}}\t{value}")
            print()

    def display_sources(self, shall=True, props=False):
        '''
        Display a formatted table of the sources. If props is given, then
        display the property lists for each sources as well.

        :param bool shall: Whether to show monitors (defaults to True)
        :param bool props: Display the property list for each source
        '''
        for source in self.sources:
            if shall or source.proplist.get("device.class", None) != "monitor":
                self.display_source(source, props=props)

    def find_source(self, query):
        '''
        Try to find a source that matches the given input query. The method of
        searching is to see if the query is an exact match to the source name,
        description, or index. A hyphen (-) can be given as the query to
        return the default source. If the query does not match _exactly_ one
        source, then None is returned. For convience, if a PulseSourceInfo
        object is given, it will be returned.

        :param query: The query of the source to search for
        :type query: str or int or PulseSourceInfo
        :return: The source found
        :rtype: PulseSourceInfo or None
        '''
        if isinstance(query, PulseSourceInfo):
            return query

        query = str(query) if query != '-' else self.default_source
        res = tuple(sc for sc in self.sources
                    if query in (sc.name, sc.description, str(sc.index)))

        return len(res) == 1 and res[0] or None

    def get_source_volumes(self, source, names=False):
        '''
        Retrieve the volumes for each channel of a source. If names is set,
        then the result will be a dict with the channel name as the key and
        volume as the value.

        :param source: The source object or query string
        :type source: PulseSourceInfo or str or int
        :param bool names: Whether or not to include channel names
        :return: A tuple of volumes or dict of name:volume pairs
        :rtype: tuple or dict
        :raises ValueError: If source not found
        '''
        scobj = self.find_source(source)
        if not scobj:
            raise ValueError(f"Source {source} not found")

        if names:
            return {n: trueround(v * 100)
                    for n, v in zip(scobj.channel_list, scobj.volume.values)}
        else:
            return tuple(trueround(value * 100)
                         for value in scobj.volume.values)

    def is_source_muted(self, source):
        '''
        Retrieves whether or not a source is muted.

        :param source: The source object or query string
        :type source: PulseSourceInfo or str or int
        :return: The mute status of the source
        :rtype: int
        :raises ValueError: If source not found
        '''
        scobj = self.find_source(source)
        if not scobj:
            raise ValueError(f"Source {source} not found")
        return scobj.mute

    def mute_source(self, source, mute):
        '''
        Set the mute status of a source.

        :param source: The source object or query string
        :type source: PulseSourceInfo or str or int
        :param mute: '0' (mute), '1' (audible), or 't' (toggle)
        :type mute: str or int
        :raises ValueError: If source not found or the mute state is invalid
        '''
        scobj = self.find_source(source)
        if not scobj:
            raise ValueError(f"Source {source} not found")

        if mute == 't':
            mute = 0 if scobj.mute else 1

        if mute is not None:
            self._client.source_mute(scobj.index, int(mute))
        else:
            raise ValueError(f"Mute should be '0', '1', or 't' not {mute}")

    def set_source_volumes(self, source, volumes):
        '''
        Set the volume for the channels of a source.

        :param source: The source object or query string
        :type source: PulseSourceInfo or str or int
        :param volumes: The volumes for each channel or a flat volume
        :type volumes: list or tuple
        :raises ValueError: If source not found or incorrect channel count
        '''
        scobj = self.find_source(source)
        if not scobj:
            raise ValueError(f"Source {source} not found")

        if len(volumes) == scobj.channel_count:
            volinfo = PulseVolumeInfo([v / 100 for v in volumes])
        elif len(volumes) == 1:
            flatvol = [v / 100 for v in volumes]
            volinfo = PulseVolumeInfo(flatvol * scobj.channel_count)
        else:
            raise ValueError(f"Source {source} has {scobj.channel_count} "
                             "channels. Provide a volume per channel or a "
                             "single flat volume")

        self._client.source_volume_set(scobj.index, volinfo)

    def set_source_volumes_relative(self, source, volumes):
        '''
        Adjust the volume for the channels of a source by a relative amount

        :param source: The source object or query string
        :type source: PulseSourceInfo or str or int
        :param volumes: The relative volume(s) to adjust by
        :type volumes: list or tuple
        :raises ValueError: If source not found or incorrect channel count
        '''
        scobj = self.find_source(source)
        if not scobj:
            raise ValueError(f"Source {source} not found")

        current = scobj.volume.values
        if len(volumes) == scobj.channel_count:
            volinfo = PulseVolumeInfo([c + v / 100
                                       for c, v in zip(current, volumes)])
        elif len(volumes) == 1:
            volinfo = PulseVolumeInfo([c + volumes[0] / 100 for c in current])
        else:
            raise ValueError(f"Source {source} has {scobj.channel_count}"
                             "channels. Provide a volume per channel or a "
                             "single flat volume")

        self._client.source_volume_set(scobj.index, volinfo)


class SourceOutputController(BaseController):
    '''
    Wrapper around source-outputs in PulseAudio.
    '''

    def __init__(self, clientobj):
        '''
        Create a wrapper around source-outputs.
        '''
        BaseController.__init__(self, clientobj)

    def display_source_output(self, soutput, pid=False, props=False):
        '''
        Display source-outputs for the client. The source-output may be given
        as a query or PulseSourceOutputInfo object. If a query is given, the
        pid keyword will control whether or not to search based on the pid of
        the application associated with the source-output. If props is given,
        the property list will be outputted.

        :param soutput: The source-output or query
        :type soutput: PulseSourceInfo or None
        :param bool pid: Whether or not to interpret the query as a pid
        :param bool props: Whether or not to output the property lists
        :raises ValueError: If the source-output is not found
        :raises RuntimeError: If output is associated with an unknown source
        '''
        # Find the source-output
        soobj = self.find_source_output(soutput, pid=pid)
        if not soobj:
            raise ValueError(f"source-output {soutput} not found")

        # Find the source that it is being outputted to
        sobj = self.find_source(soobj.source)
        if not soobj:
            raise RuntimeError(f"source-output {soutput} is using unknown "
                               "source")

        # Indicitors
        muteind = soobj.mute and 'M' or ' '

        # Print basic information
        width = max(30, self.max_source_output_width)
        sourcewidth = max(30, self.max_source_width)
        print(f"{soobj.index:6} {soobj.name:{width}} {soobj.source:2} ",
              f"{sobj.name:{sourcewidth}} {muteind}", end='')
        for value in soobj.volume.values:
            print(f" {trueround(value * 100):3}", end='')
        print()

        # If desired, print proplist
        if props:
            size = len(max(soobj.proplist.keys(), key=len))
            for key, value in sorted(soobj.proplist.items()):
                print(f"\t{key:{size}}\t{value}")
            print()

    def display_source_outputs(self, shall=False, props=False):
        '''
        Display the source-outputs in a table. If the props keyword is
        True, then the property lists will be outputted.
        '''
        for soutput in self.source_outputs:
            self.display_source_output(soutput, props=props)

    def find_source_output(self, query, pid=False):
        '''
        Try to find a source-output that matches a given output query. By
        default, the search checks to see if the name or index of any
        source-output matches the query. If the pid keyword is set to True,
        then the property `application.process.id` is checked instead. If the
        query does not match _exactly_ one source-output, then None is
        returned. For convience, if a PulseSourceOutputInfo is given as the
        query, it will be returned.

        :param query: The query of the source-output to search for
        :type query: str or int or PulseSourceOutputInfo
        :param bool pid: Check the associated pid instead (default is False)
        :return: The source-output found
        :rtype: PulseSourceOutputInfo or None
        '''
        if isinstance(query, PulseSourceOutputInfo):
            return query

        query = str(query)
        if pid:
            res = tuple(s for s in self.source_outputs
                        if str(query) in (s.pid, ))
        else:
            res = tuple(s for s in self.source_outputs
                        if str(query) in (s.name, str(s.index)))

        return len(res) == 1 and res[0] or None

    def get_source_output_pid(self, soutput):
        '''
        Retrieve the pid of the source-output.

        :param soutput: The source-output or query string
        :type soutput: PulseSourceOutputInfo or str or int
        :return: The pid of the source-output, if one is associated
        :rtype: int or None
        '''
        soobj = self.find_source_output(soutput, pid=False)
        if not soobj:
            raise ValueError(f"Source-output {soutput} not found")
        return soobj.pid

    def get_source_output_source(self, soutput, pid=False):
        '''
        Retrieve which source a source-output is playing out of.

        :param soutput: The source-output object or query string
        :type soutput: PulseSourceOutputInfo or str or int
        :param bool pid: Whether or not to interpret the query as a pid
        :return: The source
        :rtype: PulseSourceInfo
        :raises ValueError: If the source-output is not found
        '''
        soobj = self.find_source_output(soutput, pid=pid)
        if not soobj:
            raise ValueError(f"Source-output {soutput} not found")
        return self.find_source(soobj.source)

    def get_source_output_volumes(self, soutput, names=False, pid=False):
        '''
        Retrieve the volumes for each channel of a source-output. If names is
        set, then the result will be a dict with the channel name as the key
        and volume as the value.

        :param soutput: The source-output object or query string
        :type soutput: PulseSourceOutputInfo or str or int
        :param bool names: Whether or not to include channel names
        :param bool pid: Whether or not to interpret the query as a pid
        :return: A tuple of volumes or dict of name:volume pairs
        :rtype: tuple or dict
        :raises ValueError: If source-output not found
        '''
        soobj = self.find_source_output(soutput, pid=pid)
        if not soobj:
            raise ValueError(f"Source-output {soutput} not found")

        if names:
            return {n: trueround(v * 100)
                    for n, v in zip(soobj.channel_list, soobj.volume.values)}
        else:
            return tuple(trueround(value * 100)
                         for value in soobj.volume.values)

    def is_source_output_muted(self, soutput, pid=False):
        '''
        Retrieves whether or not a source-output is muted.

        :param soutput: The source-output object or query string
        :type soutput: PulseSourceOutputInfo or str or int
        :param bool pid: Whether or not to treat the query as a pid
        :return: The mute status of the source-output
        :rtype: int
        :raises ValueError: If source-output not found
        '''
        soobj = self.find_source_output(soutput, pid=pid)
        if not soobj:
            raise ValueError(f"Source-output {soutput} not found")
        return soobj.mute

    def move_source_output(self, soutput, source, pid=False):
        '''
        Move a source-output to a source.

        :param soutput: The source-output object or query string
        :type soutput: PulseSourceOutputInfo or str or int
        :param source: The source object or query string
        :type source: PulseSourceInfo or str or int
        :param bool pid: Whether or not to interpret the query as a pid
        :raises ValueError: If the source-output or source is not found
        '''
        # Find source-output
        soobj = self.find_source_output(soutput, pid=pid)
        if not soobj:
            raise ValueError(f"Source-output {soutput} not found")

        # Find source
        sobj = self.find_source(source)
        if not sobj:
            raise ValueError(f"Source {source} not found")

        # Move to source
        self._client.source_output_move(soobj.index, sobj.index)

    def mute_source_output(self, soutput, mute, pid=False):
        '''
        Set the mute status of a source-output.

        :param soutput: The source-output object or query string
        :type soutput: PulseSourceOutputInfo or str or int
        :param mute: '0' (mute), '1' (audible), or 't' (toggle)
        :type mute: str or int
        :param bool pid: Whether or not to treat the query as a pid
        :raises ValueError: If source-output not found or invalid mute status
        '''
        soobj = self.find_source_output(soutput, pid=pid)
        if not soobj:
            raise ValueError(f"Source-output {soutput} not found")

        if mute == 't':
            mute = 0 if soobj.mute else 1

        if mute is not None:
            self._client.source_output_mute(soobj.index, int(mute))
        else:
            raise ValueError(f"Mute should be '0', '1', or 't' not {mute}")

    def set_source_output_volumes(self, soutput, volumes, pid=False):
        '''
        Set the volume for the channels of a source-output.

        :param soutput: The source-output object or query string
        :type soutput: PulseSourceOutputInfo or str or int
        :param volumes: The volumes for each channel or a flat volume
        :type volumes: list or tuple
        :param bool pid: Whether or not to interpret the query as a pid
        :raises ValueError: If source not found or incorrect channel count
        '''
        soobj = self.find_source_output(soutput, pid=pid)
        if not soobj:
            raise ValueError(f"Source-output {soutput} not found")

        if len(volumes) == soobj.channel_count:
            volinfo = PulseVolumeInfo([v / 100 for v in volumes])
        elif len(volumes) == 1:
            flatvol = [v / 100 for v in volumes]
            volinfo = PulseVolumeInfo(flatvol * soobj.channel_count)
        else:
            raise ValueError(f"Source-output {soutput} has "
                             f"{soobj.channel_count} channels. Provide a "
                             "volume per channel or a single flat volume")

        self._client.source_output_volume_set(soobj.index, volinfo)

    def set_source_output_volumes_relative(self, soutput, volumes, pid=False):
        '''
        Adjust the volume for the channels of a source-output by a relative
        amount.

        :param soutput: The source-output object or query string
        :type soutput: PulseSourceOutputInfo or str or int
        :param volumes: The relative volume(s) to adjust by
        :type volumes: list or tuple
        :param bool pid: Whether or not to interpret the query as a pid
        :raises ValueError: If source not found or incorrect channel count
        '''
        soobj = self.find_source_output(soutput, pid=pid)
        if not soobj:
            raise ValueError(f"Source-output {soutput} not found")

        current = soobj.volume.values
        if len(volumes) == soobj.channel_count:
            volinfo = PulseVolumeInfo([c + v / 100
                                       for c, v in zip(current, volumes)])
        elif len(volumes) == 1:
            volinfo = PulseVolumeInfo([c + volumes[0] / 100 for c in current])
        else:
            raise ValueError(f"Source-output {soutput} has "
                             f"{soobj.channel_count} channels. Provide a "
                             "volume per channel or a single flat volume")

        self._client.source_output_volume_set(soobj.index, volinfo)


class RSFPACParser(object):
    '''
    Parser for rsfpac commands. Since sub-classing argparse.ArgumentParser
    breaks it, this is merely a wrapper to segment the code.
    '''

    def __init__(self, interactive=False):
        '''
        An argument parser for rsfpac commands.

        :param bool interactive: Whether or not to supress usage + description
        '''
        # Determine the keywords to use for the parser
        keywords = {}
        if interactive:
            keywords['usage'] = argparse.SUPPRESS
        else:
            keywords['description'] = "A script for controlling PulseAudio"

        # Create the parser
        self.__parser = argparse.ArgumentParser(**keywords)
        subpar = self.__parser.add_subparsers(dest='command',
                metavar="command",
                help="see <command> -h for more detailed help")

        # sinks sub-parser
        sinks = subpar.add_parser('sinks', aliases=['s'],
                help="retrieve information about one or more sinks")
        sinks.add_argument('-P', '--props', action='store_true',
                help="show the property list for sinks")
        sinks.add_argument('sink', type=str, nargs='?',
                help="the sink to display information for ('-' for default)")

        # sink-default sub-parser
        sinkdef = subpar.add_parser('sink-default', aliases=['sd'],
                help="retrieve or set the default sink")
        sinkdef.add_argument('-s', '--status', action='store_true',
                help="format the default sink for an status monitor")
        sinkdef.add_argument('-d', '--description', action='store_true',
                help="(-s only) show description instead of name")
        sinkdef.add_argument('-v', '--volsym', type=str,
                help="(-s only) set the volume indicator symbol")
        sinkdef.add_argument('-m', '--mutesym', type=str,
                help="(-s only) set the muted indicator symbol")
        sinkdef.add_argument('sink', type=str, nargs='?',
                help="the sink to set as default")

        # sink-mute sub-parser
        sinkmute = subpar.add_parser('sink-mute', aliases=['sm'],
                help="retrieve or set the mute status of a sink")
        sinkmute.add_argument('sink', type=str,
                help="the sink to get/set the mute state of ('-' for default)")
        sinkmute.add_argument('mute', type=str, choices=['0', '1', 't'],
                nargs='?', help="the mute status to set")

        # sink-volume sub-parser
        sinkvol = subpar.add_parser('sink-volume', aliases=['sv'],
                help="retrieve or set the volumes for a sink")
        sinkvol.add_argument('-n', '--names', action='store_true',
                help='display the channel name(s) with the volume')
        sinkvol.add_argument('sink', type=str,
                help="the sink to get/set the volumes for ('-' for default)")
        sinkvol.add_argument('volumes', type=int, nargs='*',
                help="the volume(s) to set the sink channel(s) to")

        # sink-volume-relative sub-parser
        sinkvolrel = subpar.add_parser('sink-volume-relative', aliases=['svr'],
                help="set the relative volumes for a sink")
        sinkvolrel.add_argument('sink', type=str,
                help="the sink to get/set the volumes for ('-' for default)")
        sinkvolrel.add_argument('volumes', type=int, nargs='+',
                help="the relative volume(s) to adjust the sink channel(s) by")

        # sink-inputs sub-parser
        sinputs = subpar.add_parser('sink-inputs', aliases=['si'],
                help="retrieve information about one or more sink-inputs")
        sinputs.add_argument('-a', '--showall', action='store_true',
                help="show all inputs including filters")
        sinputs.add_argument('-P', '--props', action='store_true',
                help="show the property list for the sink-inputs")
        sinputs.add_argument('-p', '--pid', action='store_true',
                help="attempt to search for a sink-input for a pid")
        sinputs.add_argument('sinkinput', type=str, nargs='?',
                help="the sink-input to display information for")

        # sink-input-mute sub-parser
        sinpmute = subpar.add_parser('sink-input-mute', aliases=['sim'],
                help="retrieve or set the mute status of a sink-input")
        sinpmute.add_argument('-p', '--pid', action='store_true',
                help="attempt to search for a sink-input for a pid")
        sinpmute.add_argument('sinkinput', type=str,
                help="the sink-input to retrieve/set the mute status for")
        sinpmute.add_argument('mute', type=str, choices=['0', '1', 't'],
                nargs='?', help="the mute status to set")

        # sink-input-pid sub-parser
        sinppid = subpar.add_parser('sink-input-pid', aliases=['sip'],
                help="retrieve the pid of a sink-input")
        sinppid.add_argument('sinkinput', type=str,
                help="the sink-input to retrieve the pid for")

        # sink-input-sink sub-parser
        sinpsink = subpar.add_parser('sink-input-sink', aliases=['sis'],
                help="retrieve or set the sink that a sink-input is using")
        sinpsink.add_argument('-p', '--pid', action='store_true',
                help="attempt to search for a sink for a pid")
        sinpsink.add_argument('sinkinput', type=str,
                help="the sink-input to retrieve/set the sink for")
        sinpsink.add_argument('sink', type=str, nargs='?',
                help="the sink to move the sink to ('-' for default)")

        # sink-input-volumes sub-parser
        sinpvol = subpar.add_parser('sink-input-volumes', aliases=['siv'],
                help="retrieve or set the volume(s) for a sink-input")
        sinpvol.add_argument('-n', '--names', action='store_true',
                help='display the channel name(s) with the volume')
        sinpvol.add_argument('-p', '--pid', action='store_true',
                help="attempt to search for a sink for a pid")
        sinpvol.add_argument('sinkinput', type=str,
                help="the sink-input to retrieve/set the volume for")
        sinpvol.add_argument('volumes', type=int, nargs='*',
                help="the volume(s) to set the sink-input channel(s) to")

        # sink-input-volumes-relative sub-parser
        sinpvol = subpar.add_parser('sink-input-volumes-relative',
                aliases=['sivr'],
                help="adjust the volume(s) for a sink-input relatively")
        sinpvol.add_argument('-p', '--pid', action='store_true',
                help="attempt to search for a sink for a pid")
        sinpvol.add_argument('sinkinput', type=str,
                help="the sink-input to retrieve/set the volume for")
        sinpvol.add_argument('volumes', type=int, nargs='+',
                help="the volume(s) to set the sink-input channel(s) to")

        # sources sub-parser
        sources = subpar.add_parser('sources', aliases=['sc'],
                help="retrieve information about one or more sources")
        sources.add_argument('-m', '--nomonitors', action='store_false',
                help="exclude monitors from source list")
        sources.add_argument('-P', '--props', action='store_true',
                help="show the property list for source")
        sources.add_argument('source', type=str, nargs='?',
                help="the source to display information for ('-' for default)")

        # source-default sub-parser
        sourcedef = subpar.add_parser('source-default', aliases=['scd'],
                help="retrieve or set the default source")
        sourcedef.add_argument('source', type=str, nargs='?',
                help="the source to set as default")

        # source-mute sub-parser
        sourcemute = subpar.add_parser('source-mute', aliases=['scm'],
                help="retrieve or set the mute status of a source")
        sourcemute.add_argument('source', type=str,
                help="the source to g/set the mute state of ('-' for default)")
        sourcemute.add_argument('mute', type=str, choices=['0', '1', 't'],
                nargs='?', help="the mute status to set")

        # source-volume sub-parser
        sourcevol = subpar.add_parser('source-volume', aliases=['scv'],
                help="retrieve or set the volumes for a source")
        sourcevol.add_argument('-n', '--names', action='store_true',
                help='display the channel name(s) with the volume')
        sourcevol.add_argument('source', type=str,
                help="the source to get/set the volumes for ('-' for default)")
        sourcevol.add_argument('volumes', type=int, nargs='*',
                help="the volume(s) to set the source channel(s) to")

        # source-volume-relative sub-parser
        sourcevolrel = subpar.add_parser('source-volume-relative',
                aliases=['scvr'], help="set the relative volumes for a source")
        sourcevolrel.add_argument('source', type=str,
                help="the source to get/set the volumes for ('-' for default)")
        sourcevolrel.add_argument('volumes', type=int, nargs='+',
                help="the relative volume(s) to adjust the source channel(s)")

        # source-outputs sub-parser
        soutputs = subpar.add_parser('source-outputs', aliases=['so'],
                help="retrieve information about one or more source-outputs")
        soutputs.add_argument('-P', '--props', action='store_true',
                help="show the property list for the source-outputs")
        soutputs.add_argument('-p', '--pid', action='store_true',
                help="attempt to search for a source-output for a pid")
        soutputs.add_argument('sourceoutput', type=str, nargs='?',
                help="the source-output to display information for")

        # source-output-mute sub-parser
        soutmute = subpar.add_parser('source-output-mute', aliases=['som'],
                help="retrieve or set the mute status of a source-output")
        soutmute.add_argument('-p', '--pid', action='store_true',
                help="attempt to search for a source-output for a pid")
        soutmute.add_argument('sourceoutput', type=str,
                help="the source-output to retrieve/set the mute status for")
        soutmute.add_argument('mute', type=str, choices=['0', '1', 't'],
                nargs='?', help="the mute status to set")

        # source-output-pid sub-parser
        soutpid = subpar.add_parser('source-output-pid', aliases=['sop'],
                help="retrieve the pid of a source-output")
        soutpid.add_argument('sourceoutput', type=str,
                help="the source-output to retrieve the pid for")

        # source-output-source sub-parser
        soutsource = subpar.add_parser('source-output-source', aliases=['sos'],
                help="retrieve/set the source that a source-output is using")
        soutsource.add_argument('-p', '--pid', action='store_true',
                help="attempt to search for a source for a pid")
        soutsource.add_argument('sourceoutput', type=str,
                help="the source-output to retrieve/set the source for")
        soutsource.add_argument('source', type=str, nargs='?',
                help="the source to move the source to ('-' for default)")

        # source-output-volumes sub-parser
        soutvol = subpar.add_parser('source-output-volumes', aliases=['sov'],
                help="retrieve or set the volume(s) for a source-output")
        soutvol.add_argument('-n', '--names', action='store_true',
                help='display the channel name(s) with the volume')
        soutvol.add_argument('-p', '--pid', action='store_true',
                help="attempt to search for a source for a pid")
        soutvol.add_argument('sourceoutput', type=str,
                help="the source-output to retrieve/set the volume for")
        soutvol.add_argument('volumes', type=int, nargs='*',
                help="the volume(s) to set the source-output channel(s) to")

        # source-output-volumes-relative sub-parser
        soutvol = subpar.add_parser('source-output-volumes-relative',
                aliases=['sovr'],
                help="adjust the volume(s) for a source-output relatively")
        soutvol.add_argument('-p', '--pid', action='store_true',
                help="attempt to search for a source for a pid")
        soutvol.add_argument('sourceoutput', type=str,
                help="the source-output to retrieve/set the volume for")
        soutvol.add_argument('volumes', type=int, nargs='+',
                help="the volume(s) to set the source-output channel(s) to")

    def parse_args(self, args):
        '''
        Parse the arguments.

        :param args: The arguments to parse
        :type args: tuple or list
        :return: The parsed command
        :rtype: args.Namespace
        :raises SystemExit: If an invalid command is given
        '''
        err = io.StringIO()
        try:
            # Attempt to parse argument without displaying errors
            with contextlib.redirect_stderr(err):
                return self.__parser.parse_args(args)
        except SystemExit:
            # If there was an error, show help
            if err.getvalue():
                if args and len(args) > 1 and '-h' not in args:
                    # Attempt to show help for the command
                    self.parse_args((args[0], '-h'))
                else:
                    # Show general help
                    return self.__parser.parse_args(('-h', ))
            else:
                raise


class RSFPulseAudioController(SinkController, SinkInputController,
                              SourceController, SourceOutputController):
    '''
    My wrapper around PulseAudio to allow for easier controlling.
    '''

    def __init__(self, clientobj=None, interactive=False):
        '''
        Create a controller for PulseAudio.

        :param Pulse clientobj: The client to use or None
        '''
        client = clientobj or Pulse('rsfpac')
        SinkController.__init__(self, client)
        SinkInputController.__init__(self, client)
        SourceController.__init__(self, client)
        self.__parser = RSFPACParser(interactive=interactive)

    def __enter__(self):
        '''
        Return the object for use within a with statement.

        :return: The current object
        :rtype: RSFAudioController
        '''
        return self

    def __exit__(self, *args, **kw):
        '''
        Closes the client connection to the PulseAudio server. This method is
        provided for use within a with statement.

        :param tuple args: The argument list. These are ignored.
        :param dict kw: The keyword dict. These are ignored.
        '''
        self._client.close()

    def __parse(self, command):
        '''
        Parse a command and run the parsed command.

        :param command: The command to parse and run
        :type command: tuple or list
        :return: The result, if any
        :rtype: Varies
        '''
        # Parse arguments
        try:
            args = self.__parser.parse_args(command)
        except SystemExit:
            return

        # Run appropriate command
        if args.command in ('sinks', 's'):
            # Either display a single sink or all sinks
            if args.sink:
                return self.display_sink(args.sink, props=args.props)
            else:
                return self.display_sinks(props=args.props)
        elif args.command in ('sink-default', 'sd'):
            # Either set the default sink, show a status block, or retrieve
            # the default sink
            if args.sink:
                self.default_sink = args.sink
            elif args.status:
                kws = {k:v for k,v in args.__dict__.items()
                       if k in ('description', 'volsym', 'mutesym') and v}
                return self.display_default_sink_status(**kws)
            else:
                return self.default_sink
        elif args.command in ('sink-mute', 'sm'):
            # Either show mute status or mute a sink
            if args.mute:
                return self.mute_sink(args.sink, args.mute)
            else:
                return self.is_sink_muted(args.sink)
        elif args.command in ('sink-volume', 'sv'):
            # Either show the volumes or set the volumes for a sink
            if args.volumes:
                return self.set_sink_volumes(args.sink, args.volumes)
            else:
                return self.get_sink_volumes(args.sink, names=args.names)
        elif args.command in ('sink-volume-relative', 'svr'):
            # Adjust the sink channel(s) by the relative volume(s)
            return self.set_sink_volumes_relative(args.sink, args.volumes)
        elif args.command in ('sink-inputs', 'si'):
            # Either display a single sink-input or all sink-inputs
            if args.sinkinput:
                return self.display_sink_input(args.sinkinput, pid=args.pid,
                                               props=args.props)
            else:
                return self.display_sink_inputs(props=args.props,
                                                shall=args.showall)
        elif args.command in ('sink-input-mute', 'sim'):
            # Either show mute status or mute a sink-input
            if args.mute:
                return self.mute_sink_input(args.sinkinput, args.mute,
                                            pid=args.pid)
            else:
                return self.is_sink_input_muted(args.sinkinput, pid=args.pid)
        elif args.command in ('sink-input-pid', 'sip'):
            # Show the pid for a sink-input
            return self.get_sink_input_pid(args.sinkinput)
        elif args.command in ('sink-input-sink', 'sis'):
            # Either show the sink that a sink-input is set to or move a
            # sink-input to a sink
            if args.sink:
                return self.move_sink_input(args.sinkinput, args.sink,
                                            pid=args.pid)
            else:
                return self.get_sink_input_sink(args.sinkinput, pid=args.pid)
        elif args.command in ('sink-input-volumes', 'siv'):
            # Either show the volumes or set the volumes for a sink-input
            if args.volumes:
                return self.set_sink_input_volumes(args.sinkinput,
                                                   args.volumes, pid=args.pid)
            else:
                return self.get_sink_input_volumes(args.sinkinput,
                                                   names=args.names,
                                                   pid=args.pid)
        elif args.command in ('sink-input-volumes-relative', 'sivr'):
            # Adjust the volumes for a sink-input by a relative amount
            return self.set_sink_input_volumes_relative(args.sinkinput,
                                                        args.volumes,
                                                        pid=args.pid)
        elif args.command in ('sources', 'sc'):
            # Show the information for one or more sources
            if args.source:
                return self.display_source(args.source, props=args.props)
            else:
                return self.display_sources(shall=args.nomonitors,
                                            props=args.props)
        elif args.command in ('source-default', 'scd'):
            # Either display the default source or set it
            if args.source:
                self.default_source = args.source
            else:
                return self.default_source
        elif args.command in ('source-mute', 'scm'):
            # Either show mute status or mute a source
            if args.mute:
                return self.mute_source(args.source, args.mute)
            else:
                return self.is_source_muted(args.source)
        elif args.command in ('source-volume', 'scv'):
            # Either show the volumes or set the volumes for a source
            if args.volumes:
                return self.set_source_volumes(args.source, args.volumes)
            else:
                return self.get_source_volumes(args.source, names=args.names)
        elif args.command in ('source-volume-relative', 'scvr'):
            # Adjust the source channel(s) by the relative volume(s)
            return self.set_source_volumes_relative(args.source, args.volumes)
        elif args.command in ('source-outputs', 'so'):
            # Either display a single source-output or all source-outputs
            if args.sourceoutput:
                return self.display_source_output(args.sourceoutput,
                                                  pid=args.pid,
                                                  props=args.props)
            else:
                return self.display_source_outputs(props=args.props)
        elif args.command in ('source-output-mute', 'som'):
            # Either show mute status or mute a source-output
            if args.mute:
                return self.mute_source_output(args.sourceoutput, args.mute,
                                               pid=args.pid)
            else:
                return self.is_source_output_muted(args.sourceoutput,
                                                   pid=args.pid)
        elif args.command in ('source-output-pid', 'sop'):
            # Show the pid for a source-output
            return self.get_source_output_pid(args.sourceoutput)
        elif args.command in ('source-output-source', 'sos'):
            # Either show the source that a source-output is set to or move a
            # source-output to a source
            if args.source:
                return self.move_source_output(args.sourceoutput, args.source,
                                               pid=args.pid)
            else:
                return self.get_source_output_source(args.sourceoutput,
                                                     pid=args.pid)
        elif args.command in ('source-output-volumes', 'sov'):
            # Either show the volumes or set the volumes for a source-output
            if args.volumes:
                return self.set_source_output_volumes(args.sourceoutput,
                                                      args.volumes,
                                                      pid=args.pid)
            else:
                return self.get_source_output_volumes(args.sourceoutput,
                                                      names=args.names,
                                                      pid=args.pid)
        elif args.command in ('source-output-volumes-relative', 'sovr'):
            # Adjust the volumes for a source-output by a relative amount
            return self.set_source_output_volumes_relative(args.sourceoutput,
                                                           args.volumes,
                                                           pid=args.pid)
        else:
            return "Unknown Command: {args.command}"

    def repl(self):
        '''
        Run in the interactive REPL mode.
        '''
        while True:
            command = input('rsfpac> ')
            try:
                result = self.run(command)
                if result is not None:
                    print(result)
            except SystemExit:
                raise
            except Exception as ex:
                print(ex)

    def run(self, command):
        '''
        Execute a command.

        :param command: The command to run
        :type command: tuple or list or str
        :return: The result if any
        '''
        # If the command is a string, split into a list
        if isinstance(command, str):
            command = shlex.split(command)

        # If the command is 'exit' or 'quit', then do so. If it is 'help, show
        # help. Otherwise, evaluate
        if len(command) == 1 and command[0] in ('exit', 'quit'):
            raise SystemExit()
        elif len(command) == 1 and command[0] == 'help':
            return self.__parse(('-h', ))
        else:
            return self.__parse(command)


if __name__ == "__main__":
    interactive = len(sys.argv) == 1
    with RSFPulseAudioController(interactive=interactive) as rsfpac:
        if interactive:
            rsfpac.repl()
        else:
            val = rsfpac.run(sys.argv[1:])
            if val is not None:
                print(val)

# vim:ft=python:ts=4:sts=4:et:fdm=indent
